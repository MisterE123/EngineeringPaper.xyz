<script lang="ts">
  import { onMount } from 'svelte';
  import { unit } from 'mathjs';
  import { results, cells, mathCellChanged } from './stores';
  import type { CodeFunctionQueryStatement } from './parser/types';
  import type { Cell } from './cells/Cells';
  import MathCell from './cells/MathCell';
  import { type FiniteImagResult, type Result, type MatrixResult, isMatrixResult } from './resultTypes';
  import { InlineLoading, CodeSnippet } from 'carbon-components-svelte';

  export let pyodidePromise: Promise<any>;
  export let index: number;

  let cell: Cell | undefined;
  let result: Result | FiniteImagResult | MatrixResult | null = null;
  let statement: CodeFunctionQueryStatement | null = null;
  let generatedCode = "";

  onMount(() => {
    if (statement) {
      statement.generateCode = true;

      $cells = $cells;
      $mathCellChanged = true;
    }
  });
  
  function getUnitsDescription(unitsString: string): string {
    if (unitsString === "") {
      return "is unitless.";
    } else {
      return `has units of [${unit(unitsString).formatUnits()}].`;
    }
  }

  function parameterMap(name: string, index: number) {
    return `    ${name} : float\n        '${name}' ${getUnitsDescription(statement.parameterUnits[index])}`;
  }

  function parameterConversionMap(name: string, index: number) {
    const currentUnit = statement.parameterUnits[index];

    if (currentUnit === "") {
      return "";
    }
    
    const { scaleFactor, offset } = getConversionFactor(currentUnit);

    if (offset === 0) {
      if (scaleFactor === 1) {
        return "";
      } else {
        return `    ${name} = ${name} * ${scaleFactor}`;
      }
    } else {
      if (scaleFactor === 1) {
        return `    ${name} = ${name} - ${offset}`;
      } else {
        return `    ${name} = (${name} - ${offset}) * ${scaleFactor}`;
      }
    }
  }

  function getReturnConversion(outputUnit: string) {
    if (outputUnit === "") {
      return "return result";
    }
    
    const { scaleFactor, offset } = getConversionFactor(outputUnit);

    if (offset === 0) {
      if (scaleFactor === 1) {
        return `return result`;
      } else {
        return `return result / ${scaleFactor}`;
      }
    } else {
      if (scaleFactor === 1) {
        return `return result + ${offset}`;
      } else {
        return `return (result/ ${scaleFactor}) + ${offset}`;
      }
    }
  }

  function getConversionFactor(startingUnits: string) {
    const currentUnit = unit(1, startingUnits);

    let offset: number = 0;
    let scaleFactor: number;

    // @ts-ignore
    if (!currentUnit._isDerived() && currentUnit.units[0].unit.offset !== 0 ) {
      offset = currentUnit.units[0].unit.offset;
      scaleFactor = currentUnit.units[0].unit.value;
    } else {
      scaleFactor = currentUnit.value;
    }

    return {
      offset: offset,
      scaleFactor: scaleFactor
    }
  }

  $: cell = $cells[index]

  $: if (cell instanceof MathCell && cell.mathField.statement &&
        cell.mathField.statement.type === "query" && 
        cell.mathField.statement.isCodeFunctionQuery) {
      statement = cell.mathField.statement;
    } else {
      statement = null;
    }


  $: {
      const tempResult = $results[index];    
      if (tempResult && !(tempResult instanceof Array)) {
      result = tempResult;
    } else {
      result = null;
    }
  }

  $: if (statement && result && !isMatrixResult(result) && "generatedCode" in result && result.generatedCode) {
    generatedCode = `${result.generatedCode.includes('numpy') ? "import numpy\n\n": ""}def ${statement.functionName}(${statement.parameterNames.join(", ")}):
    """
    Function '${statement.functionName}' automatically generated by EngineeringPaper.xyz

    Parameters
    ----------
${statement.parameterNames.map(parameterMap).join("\n")}

    Returns
    -------
    float
        Return value ${getUnitsDescription(statement.units ?? result.units)}
    """

${statement.parameterNames.map(parameterConversionMap).filter(value => value !== "").join("\n")}

    result = ${result.generatedCode}
    
    ${getReturnConversion(statement.units ?? "")}
    `
  } else {
    generatedCode = "";
  }
</script>


{#await pyodidePromise}
  <InlineLoading description="Generating Python Code..."/>
{:then promiseReturn}
  {#if generatedCode}
    <CodeSnippet type="multi" code={generatedCode} expanded />
  {/if}
{:catch promiseError}
  <InlineLoading status="error" description={promiseError}/>
{/await}